import sqlite3
from .config import DB_PATH, ALLOWED_SENDER
from datetime import datetime, timedelta
from .logger import print_status
from .paths import DATA_DIR
import threading
from contextlib import contextmanager
from typing import Optional, List, Dict, Any, Generator

# Thread-local storage for database connections
_local = threading.local()

@contextmanager
def get_db_connection(commit_on_success: bool = True) -> Generator[sqlite3.Connection, None, None]:
    """
    Ø³ÙŠØ§Ù‚ Ø¢Ù…Ù† Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    ÙŠØ¶Ù…Ù† Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    """
    if not hasattr(_local, 'conn') or _local.conn is None:
        _local.conn = sqlite3.connect(DB_PATH, timeout=20)
        _local.conn.execute('PRAGMA journal_mode=WAL')  # ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„ØªØ²Ø§Ù…Ù†
        _local.conn.execute('PRAGMA synchronous=NORMAL')  # ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø£Ù…Ø§Ù†
        _local.conn.row_factory = sqlite3.Row

    try:
        yield _local.conn
        if commit_on_success:
            _local.conn.commit()
    except Exception as e:
        _local.conn.rollback()
        raise e
    finally:
        if commit_on_success:
            _local.conn.close()
            _local.conn = None

def parse_modem_date(date_str):
    """ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ù† ØµÙŠØºØ© Ø§Ù„Ù…ÙˆØ¯Ù… Ø¥Ù„Ù‰ ØµÙŠØºØ© SQLite"""
    try:
        if not date_str:
            return datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
        if ',' in date_str:
            date_part, time_part = date_str.split(',')
            time_part = time_part.split('+')[0].split('-')[0]
            
            year, month, day = map(int, date_part.split('/'))
            hour, minute, second = map(int, time_part.split(':'))
            
            year = 2000 + year
            
            return f"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}"
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® {date_str}: {e}", "ERROR")
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

def init_db():
    """ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„"""
    with get_db_connection() as conn:
        c = conn.cursor()
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ø¹ Ø§Ù„ÙÙ‡Ø§Ø±Ø³ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
        c.executescript('''
            -- Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id TEXT UNIQUE NOT NULL,
                username TEXT,
                phone_number TEXT,
                first_name TEXT,
                last_name TEXT,
                is_admin INTEGER DEFAULT 0,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            );
            CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id);            -- Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
            CREATE TABLE IF NOT EXISTS sms (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                status TEXT DEFAULT 'REC UNREAD',
                sender TEXT NOT NULL,
                received_date TEXT NOT NULL,
                content TEXT,
                is_sent_to_telegram INTEGER DEFAULT 0,
                verified_by INTEGER,
                deleted_from_sim INTEGER DEFAULT 0,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (verified_by) REFERENCES users(id)
            );
            CREATE INDEX IF NOT EXISTS idx_sms_sender ON sms(sender);
            CREATE INDEX IF NOT EXISTS idx_sms_date ON sms(received_date);
            CREATE INDEX IF NOT EXISTS idx_sms_verified ON sms(verified_by);
            
            -- Ø¥Ø¶Ø§ÙØ© Ø­Ù‚Ù„ status Ù„Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© (Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹)
            CREATE TABLE IF NOT EXISTS sms_temp AS SELECT * FROM sms LIMIT 0;
            PRAGMA table_info(sms);
        ''')
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ù‚Ù„ status ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        cursor = conn.execute("PRAGMA table_info(sms)")
        columns = [column[1] for column in cursor.fetchall()]
        
        if 'status' not in columns:
            conn.execute('ALTER TABLE sms ADD COLUMN status TEXT DEFAULT "REC UNREAD"')
            print_status("âœ… Added status column to sms table", "SUCCESS")
        
        conn.executescript('''

            -- Ø¬Ø¯ÙˆÙ„ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªØ­Ù‚Ù‚
            CREATE TABLE IF NOT EXISTS verification (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                sms_id INTEGER,
                status TEXT CHECK(status IN ('success', 'failed')),
                verified_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id),
                FOREIGN KEY (sms_id) REFERENCES sms(id)
            );
            CREATE INDEX IF NOT EXISTS idx_verification_user ON verification(user_id);
            CREATE INDEX IF NOT EXISTS idx_verification_sms ON verification(sms_id);
            CREATE INDEX IF NOT EXISTS idx_verification_status ON verification(status);
        ''')
        
        print_status("âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ‡Ø§Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­", "SUCCESS")

def verify_message_saved(sender, content):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('SELECT id FROM sms WHERE sender = ? AND content = ?', (sender, content))
            result = cursor.fetchone()
            return result is not None
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}", "ERROR")
        return False

def message_exists(sender, content):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('SELECT id FROM sms WHERE sender = ? AND content = ?', (sender, content))
            result = cursor.fetchone()
            if result:
                print_status(f"Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", "DEBUG")
                return True
            return False
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}", "ERROR")
        return False

def save_sms(status, sender, timestamp, content):
    """Ø­ÙØ¸ Ø±Ø³Ø§Ù„Ø© SMS Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±"""
    try:
        # ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ØµÙŠØºØ© Ù…ÙˆØ­Ø¯Ø©
        parsed_date = parse_modem_date(timestamp)
          with get_db_connection() as conn:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ø³Ø§Ù„Ø© Ù…Ù…Ø§Ø«Ù„Ø© ÙÙŠ Ø¢Ø®Ø± 5 Ø¯Ù‚Ø§Ø¦Ù‚ (ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±)
            cursor = conn.execute('''
                SELECT id FROM sms 
                WHERE sender = ? AND content = ? 
                AND datetime(received_date) > datetime('now', '-5 minutes')
                LIMIT 1
            ''', (sender, content))
            
            existing = cursor.fetchone()
            if existing:
                print_status(f"âš ï¸ Duplicate message detected, skipping save", "WARN")
                return True  # Return True to indicate "handled" (even if duplicate)
            
            # Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            conn.execute(
                'INSERT INTO sms (status, sender, received_date, content, is_sent_to_telegram) VALUES (?, ?, ?, ?, 0)',
                (status, sender, parsed_date, content)
            )
            print_status(f"ğŸ“ New SMS saved to database", "SUCCESS")
            return True
            
    except sqlite3.Error as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}", "ERROR")
        return False

def mark_message_deleted(msg_id):
    """ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø´Ø±ÙŠØ­Ø©"""
    try:
        with get_db_connection() as conn:
            conn.execute('UPDATE sms SET deleted_from_sim = 1 WHERE id = ?', (msg_id,))
            return True
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}", "ERROR")
        return False

def get_user_by_telegram_id(telegram_id):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute(
                'SELECT * FROM users WHERE telegram_id = ?',
                (telegram_id,)
            )
            result = cursor.fetchone()
            return dict(result) if result else None
    except sqlite3.Error as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}", "ERROR")
        return None

def save_or_update_user(telegram_id, username=None, phone_number=None, is_admin=0):
    """Ø­ÙØ¸ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    try:
        with get_db_connection() as conn:
            conn.execute('''INSERT INTO users (telegram_id, username, phone_number, is_admin)
                           VALUES (?, ?, ?, ?)
                           ON CONFLICT(telegram_id) 
                           DO UPDATE SET username=?, phone_number=?''',
                         (telegram_id, username, phone_number, is_admin, username, phone_number))
            return True
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸/ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}", "ERROR")
        return False

def add_verification(user_id: int, sms_id: Optional[int], status: str, retries: int = 3) -> bool:
    """
    Ø¥Ø¶Ø§ÙØ© Ø¹Ù…Ù„ÙŠØ© ØªØ­Ù‚Ù‚ Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
    """
    for attempt in range(retries):
        try:
            with get_db_connection() as conn:
                conn.execute('''
                    INSERT INTO verification (user_id, sms_id, status)
                    VALUES (?, ?, ?)
                ''', (user_id, sms_id, status))
                return True
        except sqlite3.Error as e:
            if attempt == retries - 1:
                print_status(f"ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø¹Ø¯ {retries} Ù…Ø­Ø§ÙˆÙ„Ø§Øª: {e}", "ERROR")
                return False
            continue
    return False

def get_transaction_by_details(amount: float, date: str, time: str, margin_minutes: int = 0) -> Optional[Dict[str, Any]]:
    """
    Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù…Ù„ÙŠØ© ØªØ¹Ø¨Ø¦Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª ÙÙ‚Ø· (received_date)ØŒ ÙˆØ§Ù„Ù…Ø¨Ù„Øº ÙŠÙØ³ØªØ®Ø±Ø¬ Ù…Ù† content
    ÙŠØ¨Ø­Ø« ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„Ù…Ø±Ø³Ù„
    """
    try:
        with get_db_connection(commit_on_success=False) as conn:
            c = conn.cursor()
            target_dt = datetime.strptime(f"{date} {time}", "%d/%m/%Y %H:%M")
            start_dt = target_dt - timedelta(minutes=margin_minutes) if margin_minutes > 0 else target_dt
            end_dt = target_dt + timedelta(minutes=margin_minutes) if margin_minutes > 0 else target_dt
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø±Ø³Ù„ÙŠÙ†
            query = '''
                SELECT s.*, v.user_id as verified_by_user
                FROM sms s
                LEFT JOIN verification v ON s.id = v.sms_id AND v.status = 'success'
                WHERE strftime('%Y-%m-%d %H:%M', s.received_date) BETWEEN ? AND ?
            '''
            c.execute(query, (
                start_dt.strftime("%Y-%m-%d %H:%M"),
                end_dt.strftime("%Y-%m-%d %H:%M")
            ))
            results = c.fetchall()
            
            # ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¨Ù„Øº Ø¯Ø§Ø®Ù„ content ÙÙ‚Ø· Ø¨Ø¹Ø¯ Ø¬Ù„Ø¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
            for row in results:
                content = row['content'] or ''
                # Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ù…Ø¨Ù„Øº ÙƒÙ€ 1400 Ø£Ùˆ 1400.00 Ø£Ùˆ 1400,00
                if (f"{int(float(amount))}" in content or f"{float(amount):.2f}" in content or f"{float(amount):.2f}".replace('.', ',') in content):
                    return dict(row)
            return None
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: {e}", "ERROR")
        return None

def get_unverified_messages():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('''SELECT * FROM sms 
                                    WHERE verified_by IS NULL 
                                    ORDER BY received_date ASC''')
            messages = cursor.fetchall()
            return [dict(msg) for msg in messages]
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§: {e}", "ERROR")
        return []

def get_user_stats(user_id):
    """Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø© ÙÙ‚Ø·"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            # Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù†Ø§Ø¬Ø­Ø© ÙÙ‚Ø·
            cursor = conn.execute('''
                SELECT 
                    COUNT(*) as successful,
                    MAX(verified_at) as last_activity
                FROM verification
                WHERE user_id = ? AND status = 'success'
            ''', (user_id,))
            
            result = cursor.fetchone()
            successful, last_activity = result if result else (0, None)
            
            return {
                'successful_verifications': successful or 0,
                'last_activity': last_activity
            }
        
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}", "ERROR")
        return {
            'successful_verifications': 0,
            'last_activity': None
        }

def get_failed_attempts_today(user_id: int) -> int:
    """
    Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙØ§Ø´Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙŠÙˆÙ…
    """
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('''
                SELECT COUNT(*) as count
                FROM verification 
                WHERE user_id = ? 
                AND status = 'failed' 
                AND DATE(verified_at) = DATE('now')
            ''', (user_id,))
            result = cursor.fetchone()
            return result['count'] if result else 0
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„ÙØ§Ø´Ù„Ø©: {e}", "ERROR")
        return 0

def get_user_last_success(user_id: int) -> Optional[Dict]:
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± Ø¹Ù…Ù„ÙŠØ© ØªØ­Ù‚Ù‚ Ù†Ø§Ø¬Ø­Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    """
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('''
                SELECT v.*, s.content, s.received_date
                FROM verification v
                LEFT JOIN sms s ON v.sms_id = s.id
                WHERE v.user_id = ? 
                AND v.status = 'success'
                ORDER BY v.verified_at DESC
                LIMIT 1
            ''', (user_id,))
            result = cursor.fetchone()
            return dict(result) if result else None
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¢Ø®Ø± Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø§Ø­: {e}", "ERROR")
        return None

def get_user_verifications(user_id: int) -> list:
    """Ø¥Ø±Ø¬Ø§Ø¹ Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªØ­Ù‚Ù‚ (success/failed) Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ†"""
    try:
        with get_db_connection(commit_on_success=False) as conn:
            cursor = conn.execute('''SELECT * FROM verification WHERE user_id = ? ORDER BY verified_at DESC''', (user_id,))
            return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        print_status(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªØ­Ù‚Ù‚ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}", "ERROR")
        return []